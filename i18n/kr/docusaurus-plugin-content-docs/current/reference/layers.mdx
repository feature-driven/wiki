---
sidebar_position: 1
pagination_next: reference/slices-segments
---

# 계층

계층(Layers)은 Feature-Sliced Design의 가장 기본적인 조직 계층입니다. 이 계층의 주된 목적은 코드의 책임 정도와 다른 모듈에 대한 의존성을 기준으로 코드를 체계적으로 분리하는 데 있습니다. 각 계층은 코드가 맡아야 할 역할과 의존성을 결정하는 데 중요한 의미를 가집니다.

총 **7개의 계층**이 정의되어 있으며, 아래는 책임과 의존성의 정도가 높은 순서대로 정렬한 계층들입니다:

<img src="/img/layers/folders-graphic-light.svg#light-mode-only" width="180" style={{ float: "right", margin: "0 1em" }} alt="A file system tree, with a single root folder called src and then seven subfolders: app, processes, pages, widgets, features, entities, shared. The processes folder is slightly faded out." />
<img src="/img/layers/folders-graphic-dark.svg#dark-mode-only" width="180" style={{ float: "right", margin: "0 1em" }} alt="A file system tree, with a single root folder called src and then seven subfolders: app, processes, pages, widgets, features, entities, shared. The processes folder is slightly faded out." />

1. App
2. Processes (deprecated)
3. Pages
4. Widgets
5. Features
6. Entities
7. Shared

프로젝트에 모든 계층을 반드시 사용할 필요는 없습니다. 프로젝트에 실질적인 가치를 더할 수 있는 계층만 선택적으로 추가하면 충분합니다. 일반적으로 대부분의 프론트엔드 프로젝트에서는 최소한 Shared, Pages, 그리고 App 계층을 포함하는 경우가 많습니다.

실제로 각 계층은 소문자 이름의 폴더로 구성됩니다(예: `📁 shared`, `📁 pages`, `📁 app`). 또한, 계층의 역할과 의미는 표준화되어 있으므로, 새로운 계층을 추가하는 것은 _권장되지 않습니다_.

## 계층의 임포트 규칙

계층은 슬라이스(slices)라는, 높은 응집도를 가진 모듈 그룹으로 구성됩니다. 슬라이스 간의 의존성은 **계층의 임포트 규칙**에 따라 엄격히 관리됩니다:

> _슬라이스 내부의 모듈(파일)은 자신보다 아래 계층에 속한 슬라이스만 임포트할 수 있습니다._

예를 들어, `📁 ~/features/aaa` 폴더는 "aaa"라는 이름의 슬라이스입니다. 이 슬라이스 내부의 파일 `~/features/aaa/api/request.ts`는 다음과 같은 규칙을 따릅니다:
  - 같은 계층에 있는 `📁 ~/features/bbb`의 파일을 임포트할 수 없습니다.
  - 그러나, 자신보다 아래 계층에 해당하는 `📁 ~/entities`와 `📁 ~/shared`의 코드는 자유롭게 임포트할 수 있습니다.
  - 또한, 같은 슬라이스 내의 다른 파일`(~/features/aaa/lib/cache.ts)`은 임포트할 수 있습니다.

App과 Shared 계층은 이 규칙에서 **예외**입니다.<br/>
이 두 계층은 단순히 계층 역할만 하는 것이 아니라, 동시에 슬라이스로도 동작합니다.

일반적으로 슬라이스는 비즈니스 도메인별로 코드를 나누는 데 초점이 맞춰져 있지만, Shared는 비즈니스 도메인과 독립적으로 공통 코드를 제공하고, App은 모든 비즈니스 도메인을 통합하는 역할을 수행합니다.

결과적으로, App과 Shared 계층은 세그먼트로 구성되며, 이 세그먼트 간에는 자유롭게 임포트할 수 있는 유연성이 허용됩니다.

## 계층 정의

이 섹션에서는 각 계층의 의미를 명확히 설명하여, 어떤 종류의 코드가 어떤 계층에 속하는지에 대한 직관을 형성하도록 돕습니다.

### Shared (공유)

Shared 계층은 애플리케이션의 기초를 형성하는 계층입니다.<br/>
이 계층은 백엔드, 서드파티 라이브러리, 환경 등 외부 세계와 연결을 담당하며, 자체적으로 높은 응집도를 가진 라이브러리를 정의하는 곳이기도 합니다.

App 계층과 마찬가지로, Shared 계층은 _슬라이스를 포함하지 않습니다_.<br/>
슬라이스는 비즈니스 도메인별로 코드를 나누기 위한 구조지만, Shared는 비즈니스 도메인에 독립적인 계층이기 때문입니다.<br/>
결과적으로, Shared 계층의 모든 파일은 서로 참조하고 자유롭게 임포트할 수 있습니다.

이 계층에서 일반적으로 볼 수 있는 세그먼트들은 아래와 같습니다:

- `📁 api` — API 클라이언트와 특정 백엔드 엔드포인트에 요청을 보내는 함수들이 포함됩니다.
- `📁 ui` — 애플리케이션의 UI 키트가 위치합니다.
  - 이 계층의 컴포넌트는 비즈니스 로직을 포함해서는 안 되지만, 비즈니스 테마를 가지는 것은 허용됩니다.
  - 예를 들어, 회사 로고나 페이지 레이아웃과 같은 항목이 여기에 포함될 수 있습니다.
  - 또한, UI 로직을 가진 컴포넌트(예: 자동완성, 검색창)도 이 계층에 포함될 수 있습니다.
- `📁 lib` — 내부 라이브러리의 모음입니다.
  - 이 폴더는 단순한 헬퍼나 유틸리티 폴더로 취급되어서는 안 됩니다([이러한 폴더가 쓰레기통이 되는 이유][ext-sova-utility-dump])..
  - 대신, 각 라이브러리는 특정한 집중 영역(예: 날짜 처리, 색상 처리, 텍스트 조작 등)을 가져야 하며, 해당 내용은 README 파일에 명확히 문서화되어야 합니다.
  - 팀원들이 각 라이브러리에 무엇을 추가할 수 있고 없는지를 명확히 이해할 수 있어야 합니다.
- `📁 config` — 앱의 전역 설정을 포함합니다. 예를 들어, 환경 변수, 전역 기능 플래그 등이 여기에 위치합니다.
- `📁 routes` — 라우트 상수 또는 라우트 매칭 패턴을 정의합니다.
- `📁 i18n` — 번역을 위한 설정 코드와 전역 번역 문자열을 포함합니다.

Shared 계층에는 추가적인 세그먼트를 포함할 수도 있지만, 세그먼트의 이름은 해당 내용의 목적을 명확히 반영해야 합니다. 예를 들어, `components`, `hooks`, `types`와 같은 이름은 세그먼트의 본질을 구체적으로 설명하지 않기 때문에 적합하지 않습니다.<br/>
이와 같은 이름은 코드를 찾거나 이해하는 데 혼란을 줄 수 있으므로, 구체적이고 목적이 명확한 이름을 사용하는 것이 좋습니다.

### Entities (엔티티)

**엔티티 슬라이스(Entity Slice)** 는 다음과 같은 요소들을 포함할 수 있습니다:

- 데이터 저장소 (`📁 model`)
엔티티와 관련된 데이터 구조나 상태를 관리합니다.

- 데이터 검증 스키마 (`📁 model`)
엔티티의 데이터를 검증하기 위한 스키마를 정의합니다.

- API 요청 함수 (`📁 api`)
엔티티와 관련된 API 요청 함수들이 위치합니다.

- 엔티티의 시각적 표현 (`📁 ui`)
인터페이스에서 이 엔티티의 시각적 표현을 담당합니다.
  - 여기서 시각적 표현은 완전한 UI 블록을 생성할 필요는 없습니다.
  - 대신, 앱의 여러 페이지에서 동일한 외관을 재사용할 수 있도록 설계됩니다.
  - 비즈니스 로직은 props나 슬롯을 통해 연결될 수 있습니다.

#### 엔티티 관계

FSD에서 엔티티는 슬라이스이며, 기본적으로 각 슬라이스는 서로를 알 수 없습니다. 하지만 현실적으로, 엔티티들 간에 상호작용이 발생하는 경우가 많습니다. 때로는 하나의 엔티티가 다른 엔티티를 소유하거나 포함하기도 합니다.<br/>
이러한 특성 때문에, 엔티티 간 상호작용에 필요한 비즈니스 로직은 Features나 Pages와 같은 상위 계층에 두는 것이 적절합니다.

한 엔티티의 데이터 객체가 다른 데이터 객체를 포함할 때, `@x` 표기법을 사용하여 엔티티 간의 연결을 명시적으로 표현하는 것이 좋습니다.
  - 이 표기법은 슬라이스 격리를 우회하면서도 엔티티 간의 관계를 명확히 드러냅니다.
  - 연결된 엔티티들은 함께 리팩토링되어야 할 가능성이 높기 때문에, 이 연결을 명확히 표현하여 놓치지 않도록 하는 것이 중요합니다.

예를 들어:

```ts title="entities/artist/model/artist.ts"
import type { Song } from "entities/song/@x/artist";

export interface Artist {
  name: string;
  songs: Array<Song>;
}
```

```ts title="entities/song/@x/artist.ts"
export type { Song } from "../model/song.ts";
```

`@x` 표기법에 대해 자세히 알아보려면 [교차 임포트를 위한 공개 API][public-api-for-cross-imports] 섹션을 참조하세요.

### Features (기능)

이 계층은 앱에서 사용자가 관심을 가지는 주요 상호작용, 즉 특정 작업들을 처리하기 위한 공간입니다.<br/>
이러한 상호작용은 앱이 다루는 대상과 밀접한 관련이 있으며, 종종 비즈니스 엔티티를 포함하기도 합니다.

Features 계층을 효과적으로 사용하기 위해 기억해야 할 중요한 원칙은 **모든 것이 기능이 될 필요는 없다**는 점입니다.<br/>
무언가를 기능으로 정의해야 할지 판단하는 좋은 기준은 그것이 여러 페이지에서 재사용되는지 여부입니다.

예를 들어, 앱에 여러 에디터가 존재하고, 모든 에디터에 댓글 기능이 포함되어 있다면, 댓글은 재사용 가능한 기능으로 정의될 수 있습니다.<br/>
그러나 Features 계층은 코드를 빠르게 찾기 위한 메커니즘이므로, 너무 많은 기능이 정의되면 중요한 것들이 묻힐 수 있다는 점도 염두에 두어야 합니다.

이상적으로는, 새로운 프로젝트에 참여했을 때 페이지와 기능들을 살펴보는 것만으로 해당 프로젝트가 제공하는 기능성을 파악할 수 있어야 합니다.<br/>
따라서, 무엇을 기능으로 만들지 결정할 때는 프로젝트에 새로 합류한 사람이 중요한 코드 영역을 빠르게 찾을 수 있도록 구조를 최적화하는 것이 중요합니다.

기능 슬라이스는 폼과 같은 상호작용을 위한 UI(`📁 ui`), 작업을 수행하기 위한 API 호출(`📁 api`), 검증 및 내부 상태 관리(`📁 model`), 그리고 기능 플래그(`📁 config`)를 포함할 수 있습니다.

### Widgets (위젯)

Widgets 계층은 앱의 큰 자급자족형 UI 블록을 구성하기 위한 계층입니다.<br/>
Widgets는 여러 페이지에서 재사용되거나, 하나의 페이지에 여러 개의 큰 독립적인 블록이 존재할 때 적합합니다. 이러한 상황에서, Widgets는 그 블록 중 하나를 표현하기에 가장 유용합니다.

그러나, 특정 UI 블록이 페이지의 주요 내용을 대부분 차지하고 재사용되지 않는다면,
그 블록은 **위젯으로 정의해서는 안 되며**, 해당 페이지 내부에 직접 배치하는 것이 적합합니다.

:::tip

중첩 라우팅 시스템(예: [Remix][ext-remix]의 라우터)을 사용하는 경우, Widgets 계층을 활용하는 것이 유용할 수 있습니다.
Widgets 계층은 Pages 계층이 평면 라우팅 시스템에서 사용되는 방식과 유사하게 동작합니다.
즉, 관련된 데이터 가져오기, 로딩 상태 관리, 오류 경계 처리 등을 포함한 완전한 라우터 블록을 생성하는 데 활용할 수 있습니다.

또한, 페이지 레이아웃을 이 계층에 저장함으로써 비슷한 방식으로 관리할 수도 있습니다.

:::

### Pages (페이지)

Pages 계층은 웹사이트와 애플리케이션을 구성하는 화면 또는 활동(Activity)을 나타냅니다.<br/>
일반적으로 하나의 페이지는 하나의 슬라이스에 해당하지만, 등록 폼과 로그인 폼처럼 매우 유사한 여러 페이지가 있다면, 이를 하나의 슬라이스로 그룹화할 수도 있습니다.

팀이 여전히 페이지 코드를 쉽게 탐색할 수 있다면, 페이지 슬라이스 내부에 포함할 수 있는 코드의 양에는 제한이 없습니다.<br/>
특히, 페이지의 UI 블록이 재사용되지 않는 경우, 해당 블록을 페이지 슬라이스 안에 두는 것은 전혀 문제가 되지 않습니다.

페이지 슬라이스는 다음과 같은 주요 구성 요소를 포함합니다:

- UI 블록 및 상태 관리 (`📁 ui`)
  - 페이지의 UI, 로딩 상태, 그리고 오류 경계를 관리합니다.
- 데이터 처리 (`📁 api`)
  - 데이터 가져오기(fetching) 및 변경 요청(mutation)을 처리합니다.

일반적으로, 페이지는 전용 데이터 모델을 가지지 않습니다.<br/>
작은 상태는 개별 컴포넌트 내부에서 유지되는 것이 일반적입니다.

### Processes (프로세스)

:::caution

이 계층은 더 이상 사용되지 않습니다. 현재 명세에서는 이 계층의 사용을 피하고, 관련된 로직을 `features`와 `app` 계층으로 옮길 것을 권장합니다.

:::

Processes 계층은 여러 페이지에 걸친 상호작용을 처리하기 위한 탈출구로 설계되었습니다. 그러나 이 계층은 의도적으로 정의되지 않은 상태로 남겨져 있으며, 대부분의 애플리케이션에서는 사용하지 않는 것이 권장됩니다.

라우터 수준과 서버 수준의 로직은 App 계층에 포함되는 것이 가장 적합합니다. App 계층이 너무 커져 유지보수가 어렵거나 로직을 분리해야 할 필요가 있을 때에만 Processes 계층을 사용하는 것을 고려할 수 있습니다.

### App (앱)

App 계층은 앱 전반에 걸친 모든 종류의 문제를 다루는 계층으로, 기술적인 의미(예: 컨텍스트 제공자)와 비즈니스적인 의미(예: 분석)를 모두 포괄합니다.

이 계층은 Shared 계층과 마찬가지로 일반적으로 슬라이스를 포함하지 않습니다. 대신, 직접적으로 세그먼트를 구성하여 필요한 코드를 조직화합니다.

App 계층에서 일반적으로 포함되는 세그먼트는 다음과 같습니다:

- `📁 routes` — 라우터 설정 관련 코드
- `📁 store` — 전역 상태 관리를 위한 스토어 설정
- `📁 styles` — 애플리케이션 전반에 적용되는 전역 스타일
- `📁 entrypoint` — 애플리케이션의 진입점과 프레임워크별 설정

[public-api-for-cross-imports]: /docs/reference/public-api#public-api-for-cross-imports
[ext-remix]: https://remix.run
[ext-sova-utility-dump]: https://dev.to/sergeysova/why-utils-helpers-is-a-dump-45fo
